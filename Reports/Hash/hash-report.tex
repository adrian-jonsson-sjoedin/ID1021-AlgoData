\documentclass[a4paper,11pt]{article}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{placeins}
\usepackage[newfloat]{minted}
\usepackage{caption}

\newenvironment{code}{\captionsetup{type=listing}}{}
\SetupFloatingEnvironment{listing}{name=Code Overview}


\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=black,      
    urlcolor=blue,
    citecolor=black,
}
\begin{document}

\title{
    \textbf{Hash Report.}
}
\author{Adrian Jonsson Sj√∂din}
\date{Fall 2022}

\maketitle

\section{Task}
\label{task}
In this task we will read a file in CSV format that contains zip codes in an ordered format,  and then look for specific entries 
using different methods.  
\begin{itemize}
    \item Start with writing a linear lookup method and a binary lookup and write a small benchmark that searches for "111 15" 
    and "994 99" and explain the results. Then change the node class so that it holds an integer as code and re-run the benchmark. 
    Explain why the execution time has improved
    
    \item Use the zip codes as keys and store them in an array, using the keys as indexes in the array. Implement a lookup method and 
    compare its execution time to the binary search method in the previous class.

    \item Take all keys and convert them to a hash and store them in a array. This can be done by taking the key modulo $m$ for some 
    value $m$. Count the number of collisions for each type and see which $m$ seems to give the least number of collisions. To be able to
    handle the collisions first implement "buckets" where the buckets are a separate array. Then implement an improved version where the 
    bucket uses the array with hashes itself. Gather some statistics on how many elements you need to look at before you find the one you're 
    looking for. Compare the result with the separate array bucket implementation. 

\end{itemize}

\section{Method \& Theory}
\label{method}


\section{Result}

\begin{table}[h!]
    \begin{center}
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textbf{push} & \textbf{Depth} & \textbf{add} & \textbf{Depth}\\
            \hline
             12        & 2    & 10    & 6                           \\
             17        & 3    & 19    & 6                           \\
             17        & 4    & 16    & 6                           \\
             12        & 3    & 10    & 3                           \\
             14        & 4    & 17    & 6                           \\
             20        & 3    & 10    & 3                           \\
             11        & 4    & 14    & 6                           \\
             15        & 3    & 11    & 6                           \\
             15        & 4    & 20    & 6                           \\
             13        & 4    & 19    & 6                           \\
             12        & 5    & 15    & 6                           \\
             13        & 4    & 11    & 6                           \\
             20        & 5    & 15    & 6                           \\
             13        & 4    & 17    & 6                           \\
             17        & 2    & 10    & 6                           \\
             17        & 5    & 16    & 6                           \\
             14         &4    & 11    & 6                           \\
             17         &5    & 19    & 5                           \\
             17         &5    & 11    & 6                           \\
             17         &5    & 11    & 4                           \\
            \hline
        \end{tabular}
        \caption{Benchmark for how deep the push and add method needed to go in the tree}
        \label{tab:tree}
    \end{center}
\end{table}
\FloatBarrier
\section{Discussion}




\newpage
\FloatBarrier
\section*{Code}
All the code can be found here: \href{https://github.com/adrian-jonsson-sjoedin/ID1021-AlgoData/tree/main/Tasks/Priority-Queues/src}{GitHub}

\begin{code}
    \captionof{listing}{$\mathcal{O}(n)$ {\tt add(Integer item)} method }
    \label{code:ListQueueAdd}
    \begin{minted}{java}

\end{minted}
\end{code}

\begin{code}
    \captionof{listing}{$\mathcal{O}(n)$ {\tt remove()} method}
    \label{code:ListQueueRemove}
    \begin{minted}{java}

    \end{minted}
\end{code}

\begin{code}
    \captionof{listing}{$\mathcal{O}(1)$ {\tt remove()} method}
    \label{code:QueueListRemove}
    \begin{minted}{java}

    \end{minted}
\end{code}

\begin{code}
    \captionof{listing}{$\mathcal{O}(n)$ {\tt add(Integer item)} method}
    \label{code:QueueListAdd}
    \begin{minted}{java}

    \end{minted}
\end{code}

\begin{code}
    \captionof{listing}{$\mathcal{O}(log(n))$ {\tt add(int priority, T item)} method}
    \label{code:TreeAdd}
    \begin{minted}{java}

    \end{minted}
\end{code}
\newpage
\begin{code}
    \captionof{listing}{$\mathcal{O}(log(n))$ {\tt remove()} method}
    \label{code:TreeRemove}
    \begin{minted}{java}

    \end{minted}
\end{code}

\begin{code}
    \captionof{listing}{The {\tt push(int increment)} method}
    \label{code:TreePush}
    \begin{minted}{java}

    \end{minted}
\end{code}

\begin{code}
    \captionof{listing}{Array Heap {\tt add(int item)} method}
    \label{code:ArrayAdd}
    \begin{minted}{java}

    \end{minted}
\end{code}
\begin{code}
    \captionof{listing}{Array Heap {\tt remove()} method}
    \label{code:ArrayRemove}
    \begin{minted}{java}

    \end{minted}
\end{code}

\end{document}
